#include "segel.h"#include "request.h"#include "Waiting.h"#include "Working.h"#define POPPING_PERCENT 30//// server.c: A very, very simple web server//// To run://  ./server <portnum (above 2000)>//// Repeatedly handles HTTP requests sent to this port number.// Most of the work is done within routines written in request.c//// HW3: Parse the new arguments too//number of args greater or equal to 2,//takes the second argument and saves it in porttypedef struct params_t *Params;struct params_t{    WorkingQueue work;    WaitingQueue wait;    int num_threads;};Params paramsCreate(WorkingQueue work_queue, WaitingQueue waiting_queue, int num_threads){    Params param = malloc(sizeof(struct params_t));    if (param == NULL)    {        return NULL;    }    param->work = work_queue;    param->wait = waiting_queue;    param->num_threads = num_threads;    return param;}void getargs(int *port, int *threads, int *queue_size, char **schedalg, int argc, char *argv[]){    if (argc < 5)    {        fprintf(stderr, "Usage: %s <port> <threads> <queue_size> <schedalg>\n", argv[0]);        exit(1);    }    *port = atoi(argv[1]);    *threads = atoi(argv[2]);    *queue_size = atoi(argv[3]);    *schedalg = (char *) malloc(sizeof(char) * (strlen(argv[4]) + 1));    strcpy(*schedalg, argv[4]);    if (*threads <= 0)    {        fprintf(stderr, "Number of threads must be a positive number\n");        exit(1);    }    if (*queue_size <= 0)    {        fprintf(stderr, "Queue size must be a positive number\n");        exit(1);    }    if (strcmp(*schedalg, "block") != 0 && strcmp(*schedalg, "dt") != 0 && strcmp(*schedalg, "dh") != 0 &&        strcmp(*schedalg, "random") != 0)    {        fprintf(stderr, "Invalid Schedalg\n");        exit(1);    }}void *threadHandleRequests(void *param){    Params params = (Params) param;    int id = addThreadInfo(pthread_self());    stats s[params->num_threads];    s[id].handler_thread_id = id; //TODO check return value for -1    s[id].handler_thread_req_count = 0;    s[id].handler_thread_dynamic_req_count = 0;    s[id].handler_thread_static_req_count = 0;    req r;    while (1)    {        r = popHeadWaiting(params->wait, false);        if (r.connfd != -1)        {            workingPush(params->work, r);            requestHandle(r, &(s[id]));            workingPopHead(params->work);            Close(r.connfd);        }    }}Policy check_policy(char *schedalg){    Policy policy = DEFAULT;    if (strcmp(schedalg, "block"))    {        policy = BLOCK;    } else if (strcmp(schedalg, "dt"))    {        policy = TAIL;    } else if (strcmp(schedalg, "dh"))    {        policy = HEAD;    } else if (strcmp(schedalg, "random"))    {        policy = RANDOM;    }    return policy;}void popRandom(WaitingQueue waiting_queue){    int queue_index, curr_queue_size = getCurrSizeWaiting(waiting_queue);    int max_queue_size = getMaxSizeWaiting(waiting_queue);    double delete_amount_double = max_queue_size * (POPPING_PERCENT / 100);    int delete_amount = (int) ceil(delete_amount_double);    req r;    //assuming 0 is tail of queue, size - 1 is head of queue    for (int i = 0; i < delete_amount && curr_queue_size > 0; i++)    {        queue_index = rand() % curr_queue_size;        r = popIndexWaiting(waiting_queue, queue_index);        curr_queue_size--;        Close(r.connfd);    }}int main(int argc, char *argv[]){    int listenfd, connfd, port, clientlen, threads_amount, queue_size;    req r;    struct sockaddr_in clientaddr;    char *schedalg;    getargs(&port, &threads_amount, &queue_size, &schedalg, argc, argv);    init_stuff();    int thread_size = threads_amount;    createThreadArray(thread_size);    WorkingQueue work_queue = workingQueueCreate(thread_size);    Policy policy = check_policy(schedalg);    WaitingQueue waiting_queue = queueCreateWaiting(thread_size, policy);    srand((unsigned) time(0)); //initialize random number generator    //creating the threads    pthread_t thread_id;    Params parameters = paramsCreate(work_queue, waiting_queue, threads_amount);    for (int i = 0; i < thread_size; i++)    {        pthread_create(&thread_id, NULL, threadHandleRequests, (void *) parameters);    }    listenfd = Open_listenfd(port);    while (1)    {        clientlen = sizeof(clientaddr);        /** not sure if using locks here is starvation or busy waiting, need to check         on the other hand, if I don't use locks I won't be able to check the global variable         without fear of context switch*/        r.connfd = Accept(listenfd, (SA *) &clientaddr, (socklen_t * ) & clientlen);        pthread_mutex_lock(&lock);        if (total_handled == queue_size - 1) {            if (gettimeofday(&r.arrival_time, NULL) == -1) {                return -1;            }            pushWaiting(waiting_queue, r);            while (policy == BLOCK && total_handled == queue_size) {                //wait until a request is done, need while because of condition variable                pthread_cond_wait(&is_full, &lock);            }        }        if (total_handled < queue_size) {            goto push_and_unlock;        }        //reaching here means that total_handled == queue_size        switch (policy)        {            //Sorry Adi, couldn't stop myself            case TAIL:                Close(r.connfd);                pthread_mutex_unlock(&lock);                continue;            case RANDOM:                if (0 == getCurrSizeWaiting(waiting_queue))                {                    Close(r.connfd);                    pthread_mutex_unlock(&lock);                    continue;                }                popRandom(waiting_queue);                break;            case HEAD:                if (0 == getCurrSizeWaiting(waiting_queue))                {                    Close(r.connfd);                    pthread_mutex_unlock(&lock);                    continue;                }                popHeadWaiting(waiting_queue, true);                break;            default:                //DEFAULT only, BLOCK already handled                continue;        }        push_and_unlock:        if (gettimeofday(&r.arrival_time, NULL) == -1)        {            return -1;        }        pushWaiting(waiting_queue, r);        pthread_mutex_unlock(&lock);    }}     