#include "segel.h"#include "request.h"#include "Waiting.h"#include "Working.h"#define POPPING_PERCENT 30//// server.c: A very, very simple web server//// To run://  ./server <portnum (above 2000)>//// Repeatedly handles HTTP requests sent to this port number.// Most of the work is done within routines written in request.c//// HW3: Parse the new arguments too//number of args greater or equal to 2,//takes the second argument and saves it in porttypedef struct params_t *Params;struct params_t {    WorkingQueue work;    WaitingQueue wait;    int num_threads;};Params paramsCreate(WorkingQueue work_queue, WaitingQueue waiting_queue, int num_threads) {    Params param = malloc(sizeof(struct params_t));    if (param == NULL) {        return NULL;    }    param->work = work_queue;    param->wait = waiting_queue;    param->num_threads = num_threads;    return param;}void getargs(int *port, int *threads, int *queue_size, char **schedalg, int argc, char *argv[]) {    if (argc < 5) {        fprintf(stderr, "Usage: %s <port> <threads> <queue_size> <schedalg>\n", argv[0]);        exit(1);    }    *port = atoi(argv[1]);    *threads = atoi(argv[2]);    *queue_size = atoi(argv[3]);    *schedalg = (char *) malloc(sizeof(char) * (strlen(argv[4]) + 1));    strcpy(*schedalg, argv[4]);    if (*threads <= 0) {        fprintf(stderr, "Number of threads must be a positive number\n");        exit(1);    }    if (*queue_size <= 0) {        fprintf(stderr, "Queue size must be a positive number\n");        exit(1);    }    if (strcmp(*schedalg, "block") != 0 && strcmp(*schedalg, "dt") != 0 && strcmp(*schedalg, "dh") != 0 &&        strcmp(*schedalg, "random") != 0) {        fprintf(stderr, "Invalid Schedalg\n");        exit(1);    }}void *threadHandleRequests(void *param) {    Params params = (Params) param;    int id = addThreadInfo(pthread_self());    stats s[params->num_threads];    s[id].handler_thread_id = id; //TODO check return value for -1    s[id].handler_thread_req_count = 0;    s[id].handler_thread_dynamic_req_count = 0;    s[id].handler_thread_static_req_count = 0;    req r;    while (1) {        FILE* fp = fopen("tests_with_prints", "a");        fprintf(fp, "worker thread got in:\n");        fclose(fp);        r = popHeadWaiting(params->wait, false);        fp = fopen("tests_with_prints", "a");        fprintf(fp, "worker thread popped from waiting:\n");        fclose(fp);        //printf("returned from popHeadWaiting with req %d and thread id of %d\n", r.connfd, (int)pthread_self());//        fflush(stdout);        if (r.connfd != -1) {//            printf("[%d] started WorkingPush\n", id);//            fflush(stdout);            workingPush(params->work, r);            fp = fopen("tests_with_prints", "a");            fprintf(fp, "worker thread pushed in working:\n");            fclose(fp);//            printf("[%d] ended WorkingPush\n", id);//            fflush(stdout);//            printf("[%d] started requestHandle\n", id);//            fflush(stdout);            requestHandle(r, &(s[id]));            fp = fopen("tests_with_prints", "a");            fprintf(fp, "worker thread handled request:\n");            fclose(fp);//            printf("[%d] ended requestHandle\n", id);//            fflush(stdout);//            printf("[%d] started workingPopHead\n", id);//            fflush(stdout);            workingPopHead(params->work);            fp = fopen("tests_with_prints", "a");            fprintf(fp, "worker thread popped from working:\n");            fclose(fp);//            printf("[%d] ended workingPopHead\n", id);//            fflush(stdout);            Close(r.connfd);            fp = fopen("tests_with_prints", "a");            fprintf(fp, "worker thread closed the connection:\n");            fclose(fp);        } else {            printf("Very bad!\n");            fflush(stdout);            exit(1);        }    }}Policy check_policy(char *schedalg) {    Policy policy = DEFAULT;    if (strcmp(schedalg, "block") == 0) {        policy = BLOCK;        //printf("got into block\n");    } else if (strcmp(schedalg, "dt") == 0) {        policy = TAIL;        //printf("got into drop tail\n");    } else if (strcmp(schedalg, "dh") == 0) {        policy = HEAD;        //printf("got into drop head\n");    } else if (strcmp(schedalg, "random") == 0) {        policy = RANDOM;        //printf("got into random\n");    }    fflush(stdout);    return policy;}void popRandom(WaitingQueue waiting_queue) {    int queue_index;    int curr_queue_size = getCurrSizeWaiting(waiting_queue);    double delete_amount_double = (double) curr_queue_size * ((double) POPPING_PERCENT / (double) 100);    int delete_amount = (int) ceil(delete_amount_double);    req r;//    printf("the delete_double is %f\n", delete_amount_double);////    printf("popping %d elements\n", delete_amount);//    fflush(stdout);    //assuming 0 is tail of queue, size - 1 is head of queue    for (int i = 0; i < delete_amount && curr_queue_size > 0; i++) {        queue_index = rand() % curr_queue_size;        r = popIndexWaiting(waiting_queue, queue_index);        curr_queue_size--;        Close(r.connfd);    }}int main(int argc, char *argv[]) {    int listenfd, port, clientlen, threads_amount, queue_size;    req r;    bool almost_queue_size = false;    struct sockaddr_in clientaddr;    char *schedalg;    getargs(&port, &threads_amount, &queue_size, &schedalg, argc, argv);    init_stuff();    int thread_size = threads_amount;    createThreadArray(thread_size);    WorkingQueue work_queue = workingQueueCreate(thread_size);    Policy policy = check_policy(schedalg);    WaitingQueue waiting_queue = queueCreateWaiting(queue_size, policy);    srand((unsigned) time(0)); //initialize random number generator    //creating the threads    pthread_t thread_id;    Params parameters = paramsCreate(work_queue, waiting_queue, threads_amount);    int req_num = 1; //* *    for (int i = 0; i < thread_size; i++) {        pthread_create(&thread_id, NULL, threadHandleRequests, (void *) parameters);    }    listenfd = Open_listenfd(port);    FILE *fp = fopen("tests_with_prints", "a");    //fprintf(fp, "\n\n\n");    fprintf(fp, "policy: %s\n", schedalg);    fclose(fp);    while (1) {        clientlen = sizeof(clientaddr);        /** not sure if using locks here is starvation or busy waiting, need to check         on the other hand, if I don't use locks I won't be able to check the global variable         without fear of context switch*/        fp = fopen("tests_with_prints", "a");        fprintf(fp, "waiting for request num: %d\n", req_num);        fclose(fp);        //fflush(stdout);        r.connfd = Accept(listenfd, (SA *) &clientaddr, (socklen_t * ) & clientlen);        fp = fopen("tests_with_prints", "a");        fprintf(fp, "got request after Accept with connfd of %d\n", r.connfd);        fclose(fp);        if (r.connfd < 0) {            exit(1);        }        if (gettimeofday(&r.arrival_time, NULL) == -1) {            return -1;        }        //fflush(stdout);        if (total_handled == queue_size - 1) {            almost_queue_size = true;            fp = fopen("tests_with_prints", "a");            fprintf(fp, "got to dangerous size with req num: %d\n", req_num);            fclose(fp);            //fflush(stdout);            pthread_mutex_lock(&lock);            pushWaiting(waiting_queue, r);            pthread_mutex_unlock(&lock);            fp = fopen("tests_with_prints", "a");            fprintf(fp, "finished pushing, total_handled == queue_size\n");            fclose(fp);            //fflush(stdout);            pthread_mutex_lock(&lock);            while (policy == BLOCK && total_handled == queue_size) {                fp = fopen("tests_with_prints", "a");                fprintf(fp, "got into block while\n");                fclose(fp);                //wait until a request is done, need while because of condition variable                pthread_cond_wait(&is_full, &lock);            }            fp = fopen("tests_with_prints", "a");            fprintf(fp, "got out of block while\n");            fclose(fp);            goto push_and_unlock;        }        //fflush(stdout);        pthread_mutex_lock(&lock);        fp = fopen("tests_with_prints", "a");        fprintf(fp, "locked request num: %d\n", req_num);        fclose(fp);        if (total_handled < queue_size) {            goto push_and_unlock;        }        //reaching here means that total_handled == queue_size        switch (policy) {            //Sorry Adi, couldn't stop myself            case TAIL:                Close(r.connfd);                pthread_mutex_unlock(&lock);                continue;            case RANDOM:                fp = fopen("tests_with_prints", "a");                fprintf(fp, "queue full, got into random with req num: %d\n", req_num);                fclose(fp);                //fflush(stdout);                if (0 == getCurrSizeWaiting(waiting_queue)) {                    fp = fopen("tests_with_prints", "a");                    fprintf(fp, "closing new connection\n");                    fclose(fp);                    //fflush(stdout);                    Close(r.connfd);                    pthread_mutex_unlock(&lock);                    continue;                }                fp = fopen("tests_with_prints", "a");                fprintf(fp, "popping 30 percent\n");                fclose(fp);                //fflush(stdout);                popRandom(waiting_queue);                break;            case HEAD:                fp = fopen("tests_with_prints", "a");                fprintf(fp, "got to head with request number %d\n", req_num);                fclose(fp);                //fflush(stdout);                if (0 == getCurrSizeWaiting(waiting_queue)) {                    Close(r.connfd);                    pthread_mutex_unlock(&lock);                    continue;                }                req pop_head_req = popHeadWaiting(waiting_queue, true);                Close(pop_head_req.connfd);                total_handled--;                break;            default:                //DEFAULT only, BLOCK already handled                continue;        }    push_and_unlock:        if (!almost_queue_size) {            fp = fopen("tests_with_prints", "a");            fprintf(fp, "going to push request \n");            fclose(fp);            //fflush(stdout);            pushWaiting(waiting_queue, r);        }        fp = fopen("tests_with_prints", "a");        fprintf(fp, "the fd of current request is: %d\n", r.connfd);        fprintf(fp, "current size of WaitingQueue: %d\n", getCurrSizeWaiting(waiting_queue));        fprintf(fp, "current size of WorkingQueue: %d\n", workingGetCurrSize(work_queue));        //printf("current amount being taken care of: %d\n", total_handled);        fprintf(fp, "put request num %d in queue. unlocking: \n", req_num);        printThreadsInfo(fp);        fprintf(fp, "\n\n");        fclose(fp);        pthread_mutex_unlock(&lock);        pthread_cond_signal(&is_empty);        //fflush(stdout);        req_num++;        almost_queue_size = false;    }}     